package com.xiaofu.JMM;

/**
 * volatile:最后一个特性，就是禁止指令重排序
 * 什么叫做指令重排序？
 * 指令重排序就是程序最后执行的顺序不一定和源代码中的程序一致，而是会经过编译器的重排序，编译器
 * 会根据优化而对某些指令进行重排序，但是编译器进行指令重排序会保证数据的依赖性，在单线程环境下编译
 * 器的指令重排序是没有影响的，但是在多线程并发的情况下，编译器的指令重排序可能会导致数据不一致，请看
 * 下面一个例子
 *
 * 那么volatile为什么可以禁止指令重排序呢？
 * 首先，我们要了解内存屏障这个词，内存屏障就是cpu的指令，它的作用有两个，第一个就是强制
 * 刷出cpu的所有缓存(保证可见性),第二个就是保证特定操作的执行顺序(禁止指令重排序),在进行volatile
 * 写操作之前会加入一条store指令，将工作内存的共享变量写回到主物理内存，加入内存屏障就会禁止编译器在这条
 * 屏障指令的前后进行优化重排序，在进行volatile读操作之前会加入一条load指令，读取主物理内存共享变量最新的值，同时
 * 也禁止编译器在这条load指令前后来进行一个指令重排序
 *
 *
 */
class Data01{
    private int a=0;
    private boolean flag = false;
    // 在多线程并发环境下，由于编译器的指令重排序，从而导致的顺序为
    // flag = true ; a = 5; 在将要执行a = 5的时候，线程a突然挂起，此时
    // 线程b执行method02()方法,这样导致的结果就是最后输出结果为5,但是正常的输出结果
    // 应该为10，所以这里由于编译器的指令重排序导致了数据结果的不一致，所以我们要将上volatile关键字
    // 来禁止指令的重排序
    public void method01(){
        a = 5;
        flag = true;
    }

    public void method02(){

        if(flag){
            a = a+5;
        }
    }



}
public class VolatileDemo04 {
}
